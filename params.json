{"name":"Value-reference-types","tagline":"Le projet permet d'introduire la notion de type valeur et type référence","body":"### Introduction:\r\nDans le développement procédurale, on utilise des types tel que les entiers, les réels, les caractères.\r\nLe présent projet, permet de faire la correspondance de ces types dans le développement orienté objet avec C#.\r\n\r\n### Développement procédurale\r\nSoit le programme suivant :\r\n```\r\n#include<stdio.h>\r\n#include<conio.h>\r\n\r\nvoid Addition(int x,int y, int z);\r\n\r\nint main()\r\n{\r\n\tint Arg1 = 5;\r\n\tint Arg2 = 6;\r\n\tint Somme = 1;\r\n\tAddition(Somme,Arg1,Arg2);\r\n\tprintf(\"Somme = %d\",Somme);\r\n}\r\n\r\nvoid Addition(int x,int y, int z)\r\n{\r\n\tx = y + z;\r\n}\r\n```\r\n\r\nLe programme initialise les variables :\r\nArg1 : une variable entière qui est initialisée au début du programme avec la valeur 5.\r\nArg2 : une variable entière qui est initialisée au début du programme avec la valeur 6.\r\nSomme : une variable entière qui est initialisée au début du programme avec la valeur 1.\r\nLe programme fait appel à une fonction Addition, qui prend en paramètre 3 variables (Arg1, Arg2 et Somme). Cette dernière permet de faire l’addition des deux premiers paramètres et de mettre le résultat dans Somme. \r\nAprès l’exécution du programme, et malgré que la variable Somme a été modifié dans la fonction addition, la sortie du programme va afficher 1 !!!\r\nEn fait, lors de l’appel de la fonction Addition, le compilateur a passé les valeurs des variables et non pas leurs références. \r\nAutrement dit, soit V1, V2 et V3 trois verres.\r\nLe compilateur, et au lieu de mettre le contenu de V2 et V3 dans V1, il crée trois verres X1, X2 et X3 et il remplit X1 avec un contenu égal à V1, X2 avec un contenu égale à V2 et X3 avec un contenu égale à V3 sans toucher à V1, V2 et V3. L’opération d’addition est réalisée sur X1, X2 et X3.\r\n\r\n### Programmation orienté objet (Types valeur):\r\nSoit le programme suivant :\r\n\r\n```\r\nstatic void main(string [] args)\r\n{\r\n\tint Arg1 = 5;\r\n\tint Arg2 = 6;\r\n\tint Somme = 1;\r\n\tAddition(Somme,Arg1,Arg2);\r\n\tConsole.WriteLine(\"Somme = \" + Somme);\r\n}\r\n\r\nstatic void Addition(int a, int b, int c)\r\n{\r\n\ta = b + c;\r\n}\r\n```\r\n\r\nEn fait, le résultat du programme sera le même. Et la Console affichera «Somme = 1 ».\r\nMême le principe de calcul et le même. On dit alors qu’Arg1, Arg2, et Somme sont des types valeurs.\r\nVoici la liste complète des types valeur définit dans le Framework .Net :\r\n\r\n* bool\r\n* byte\r\n* char\r\n* decimal\r\n* double\r\n* enum\r\n* float\r\n* int\r\n* long\r\n* sbyte\r\n* short\r\n* struct\r\n* uint\r\n* ulong\r\n* ushort\r\n\r\n### Programmation orienté objet (Types référence):\r\nUne notion très connu dans le développement procédurale, est les pointeurs.\r\nLe principe est simple, au lieu de travailler avec le contenu des variables, on utilise les adresses mémoire de ces derniers.\r\n\r\nLes classes sont des types de références, en effet soit le programme suivant :\r\n```\r\nstatic void main(string [] args)\r\n{\r\n\tReferenceEntiere Arg1 = new ReferenceEntiere();\r\n\tArg1.Valeur = 5;\r\n\t\r\n\tReferenceEntiere Arg2 = new ReferenceEntiere();\r\n\tArg2.Valeur = 6;\r\n\t\r\n\tReferenceEntiere Somme = new ReferenceEntiere();\r\n\tSomme.Valeur = 6;\r\n\r\n\tAddition(Somme,Arg1,Arg2);\r\n\tConsole.WriteLine(\"Somme = \" + Somme.Valeur);\r\n}\r\n\r\nclass ReferenceEntiere\r\n{\r\n\tpublic int Valeur;\r\n}\r\n\r\nstatic void Addition(ReferenceEntiere a, ReferenceEntiere b, ReferenceEntiere c)\r\n{\r\n\ta.Valeur = b.Valeur + c.Valeur;\r\n}\r\n```\r\nLa sortie du programme est 11.\r\nLors de l’utilisation des objets, on utilise ces références. Donc lors de la modification d’une valeur dans l’objet, elle est modifiée dans la référence.\r\n\r\n### Contenu du projet :\r\n* Création d'un type de valuers.\r\n* Utilisation de l'objet Operator.\r\n* Création d'un type de référence.\r\n* Comparaison entre les deux résultat.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}